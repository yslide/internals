var searchIndex = JSON.parse('{\
"libslide":{"doc":"libslide is the core of slide, implementing the end-to-end…","i":[[3,"Assignment","libslide","An assignment.",null,null],[12,"lhs","","Left hand side of the assignment.",0,null],[12,"asgn_op","","The assignment operator.",0,null],[12,"rhs","","Right hand side of the assignment.",0,null],[12,"span","","Span of the entire assignment.",0,null],[3,"RcExpr","","An reference-counted version of an expression.",null,null],[12,"expr","","The underlying expression.",1,null],[12,"span","","The original span of this expression from an input source…",1,null],[3,"Stmt","","A statement in a slide program.",null,null],[12,"kind","","The kind of the statement.",2,null],[12,"vw","","Vertical whitespace present before the statement.",2,null],[3,"StmtList","","A list of statements in a slide program.",null,null],[12,"list","","The list of statements.",3,null],[3,"Span","","Describes the character span of a substring in a text.",null,null],[12,"lo","","Inclusive lower bound index of the span, in terms of…",4,null],[12,"hi","","Exclusive upper bound index of the span, in terms of…",4,null],[3,"ProgramContext","","A context for evaluating a slide program.",null,null],[12,"rule_denylist","","Rules that should not be included in the evaluation of an…",5,null],[12,"always_flatten","","Whether an expression should always be flattened before it…",5,null],[12,"lint","","Whether \\\"lint\\\"-like diagnostics should be emitted.",5,null],[3,"ParseResult","","Describes the result of parsing a slide program.",null,null],[12,"program","","The slide program.",6,null],[12,"diagnostics","","Parsing diagnostics encountered while scanning the program.",6,null],[3,"EvaluationResult","","Describes the result of a slide program evaluation.",null,null],[12,"simplified","","Input program statements, evaluated to as simple a form…",7,null],[12,"diagnostics","","Diagnostic",7,null],[3,"Poly","","A polynomial in integer space Z. TODO: Currently, this…",null,null],[12,"vec","","Underlying polynomial coefficient representation. The…",8,null],[3,"EmitConfig","","Configuration options for emitting a slide grammar.",null,null],[12,"bits","","",9,null],[4,"Expr","","An expression.",null,null],[13,"Const","","A constant.",10,null],[13,"Var","","A variable.",10,null],[13,"BinaryExpr","","A binary expression.",10,null],[13,"UnaryExpr","","A unary expression.",10,null],[13,"Parend","","An expression wrapped in parentheses.",10,null],[13,"Bracketed","","An expression wrapped in brackets.",10,null],[4,"ExprPat","","A slide expression pattern.",null,null],[13,"Const","","A constant",11,null],[13,"VarPat","","Pattern matching a variable",11,null],[13,"ConstPat","","Pattern matching a constant",11,null],[13,"AnyPat","","Pattern matching any expression",11,null],[13,"BinaryExpr","","A binary expression",11,null],[13,"UnaryExpr","","A unary expression",11,null],[13,"Parend","","A paranthesized expression",11,null],[13,"Bracketed","","A bracketed expression",11,null],[4,"StmtKind","","The kind of a statement.",null,null],[13,"Expr","","An expression statement is a statement that consists…",12,null],[13,"Assignment","","An assignment binds some value to a variable. For example…",12,null],[4,"EmitFormat","","The format in which a slide grammar should be emitted.",null,null],[13,"Pretty","","Canonical, human-readable form. For example, `1+1` is…",13,null],[13,"SExpression","","S-expression form. For example, `1+1` is output as `(+ 1…",13,null],[13,"Latex","","LaTeX output form. For example, `(1 + 1)` is output as…",13,null],[13,"Debug","","Slide internal debug form. NB: this form is not stable,…",13,null],[5,"parse_expression_pattern","","Parses a tokenized slide expression pattern, emitting the…",null,[[["vec",3],["token",3]],[["rcexprpat",3],["parseresult",3]]]],[5,"parse_statements","","Parses a tokenized slide program, emitting the result and…",null,[[["vec",3],["token",3]],[["parseresult",3],["stmtlist",3]]]],[5,"lint_expr_pat","","Lints a slide expression pattern.",null,[[["rcexprpat",3]],[["diagnostic",3],["vec",3]]]],[5,"lint_stmt","","Lints a slide statement list.",null,[[["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[5,"build_rules","","Given an evaluator context, builds a set of evaluator…",null,[[["programcontext",3]],[["buildruleerrors",3],["result",4],["vec",3]]]],[5,"evaluate","","Evaluates a list of statements to as simplified a form as…",null,[[["stmtlist",3],["programcontext",3]],[["box",3],["evaluationresult",3],["result",4]]]],[5,"evaluate_expr","","Evaluates an expression to as simplified a form as…",null,[[["rcexpr",3],["programcontext",3]],["rcexpr",3]]],[0,"grammar","","The primary libslide IR.",null,null],[3,"BinaryExpr","libslide::grammar","",null,null],[12,"op","","",14,null],[12,"lhs","","",14,null],[12,"rhs","","",14,null],[3,"UnaryExpr","","",null,null],[12,"op","","",15,null],[12,"rhs","","",15,null],[4,"BinaryOperator","","",null,null],[13,"Plus","","",16,null],[13,"Minus","","",16,null],[13,"Mult","","",16,null],[13,"Div","","",16,null],[13,"Mod","","",16,null],[13,"Exp","","",16,null],[4,"UnaryOperator","","",null,null],[13,"SignPositive","","",17,null],[13,"SignNegative","","",17,null],[0,"mem","","Provides memory-based utilities for slide Grammars, namely…",null,null],[3,"INTERNED_STRS","libslide::grammar::mem","Arena of interned strings.",null,null],[12,"__private_field","","",18,null],[3,"EMPTY_STR","","A static reference to an empty string.",null,null],[12,"__private_field","","",19,null],[3,"InternedStr","","An interned String type.",null,null],[12,"0","","",20,null],[3,"RcExpr","","An reference-counted version of an expression.",null,null],[12,"expr","","The underlying expression.",1,null],[12,"span","","The original span of this expression from an input source…",1,null],[3,"RcExprPat","","An reference-counted version of an expression.",null,null],[12,"expr","","The underlying expression.",21,null],[12,"span","","The original span of this expression from an input source…",21,null],[8,"RcExpression","","Describes a reference-counted slide expression.",null,null],[16,"Inner","","The type of expression held by Self.",22,null],[10,"is_const","","Returns whether the expression is a statically-evaluatable…",22,[[]]],[10,"is_var","","Returns whether the expression is a terminable variable…",22,[[]]],[10,"paren","","Paranthesizes `inner`.",22,[[["span",3]]]],[10,"bracket","","Brackets `inner`.",22,[[["span",3]]]],[10,"binary","","Creates an RcExpression from a BinaryExpr.",22,[[["binaryexpr",3],["span",3]]]],[10,"unary","","Creates an RcExpression from a UnaryExpr.",22,[[["span",3],["unaryexpr",3]]]],[10,"empty","","Returns an empty expression.",22,[[["span",3]]]],[10,"span","","Returns the span of the expression.",22,[[],["span",3]]],[11,"intern","","Interns a string, or returns the existing interned…",20,[[["asref",8]]]],[11,"get","","Gets the string interned at this reference.",20,[[],["string",3]]],[11,"new","libslide","Creates a new reference-counted expression at a span.",1,[[["expr",4]]]],[11,"new","libslide::grammar::mem","Creates a new reference-counted expression at a span.",21,[[["exprpat",4]]]],[0,"collectors","libslide::grammar","Module `collectors` provides utilities for collecting…",null,null],[3,"VarNameCollector","libslide::grammar::collectors","",null,null],[12,"vars","","",23,null],[3,"VarAsgnsCollector","","",null,null],[12,"defs","","",24,null],[3,"PatternCollector","","",null,null],[12,"pats","","",25,null],[5,"collect_var_names","","Collects unique variable names in an expression.",null,[[["rcexpr",3]],[["internedstr",3],["hashset",3]]]],[5,"collect_var_asgns","","Collects variable assignments in a program.",null,[[["stmtlist",3]],[["vec",3],["internedstr",3],["hashmap",3]]]],[5,"collect_pat_names","","Collects unique pattern names in an pattern expression.",null,[[["rcexprpat",3]],["hashset",3]]],[0,"expression_pattern","libslide::grammar","",null,null],[4,"ExprPat","libslide::grammar::expression_pattern","A slide expression pattern.",null,null],[13,"Const","","A constant",11,null],[13,"VarPat","","Pattern matching a variable",11,null],[13,"ConstPat","","Pattern matching a constant",11,null],[13,"AnyPat","","Pattern matching any expression",11,null],[13,"BinaryExpr","","A binary expression",11,null],[13,"UnaryExpr","","A unary expression",11,null],[13,"Parend","","A paranthesized expression",11,null],[13,"Bracketed","","A bracketed expression",11,null],[0,"statement","libslide::grammar","",null,null],[3,"StmtList","libslide::grammar::statement","A list of statements in a slide program.",null,null],[12,"list","","The list of statements.",3,null],[3,"StmtListIterator","","",null,null],[12,"stmts","","",26,null],[3,"Stmt","","A statement in a slide program.",null,null],[12,"kind","","The kind of the statement.",2,null],[12,"vw","","Vertical whitespace present before the statement.",2,null],[3,"Assignment","","An assignment.",null,null],[12,"lhs","","Left hand side of the assignment.",0,null],[12,"asgn_op","","The assignment operator.",0,null],[12,"rhs","","Right hand side of the assignment.",0,null],[12,"span","","Span of the entire assignment.",0,null],[4,"StmtKind","","The kind of a statement.",null,null],[13,"Expr","","An expression statement is a statement that consists…",12,null],[13,"Assignment","","An assignment binds some value to a variable. For example…",12,null],[4,"AssignmentOp","","",null,null],[13,"Equal","","=",27,null],[13,"AssignDefine","",":=",27,null],[4,"Expr","","An expression.",null,null],[13,"Const","","A constant.",10,null],[13,"Var","","A variable.",10,null],[13,"BinaryExpr","","A binary expression.",10,null],[13,"UnaryExpr","","A unary expression.",10,null],[13,"Parend","","An expression wrapped in parentheses.",10,null],[13,"Bracketed","","An expression wrapped in brackets.",10,null],[11,"new","libslide","",3,[[["stmt",3],["vec",3]]]],[11,"iter","","",3,[[],[["stmt",3],["iter",3]]]],[11,"new","","Creates a new `Stmt`.",2,[[["stmtkind",4]]]],[11,"update_with","","Update `self` with a fresh statement kind, given functions…",2,[[]]],[11,"vw","","Retrieve the number of vertical whitespace lines above…",2,[[]]],[11,"span","","Gets the span of the statement.",2,[[],["span",3]]],[11,"span","libslide::grammar::statement","",27,[[],["span",3]]],[11,"redefine_with","libslide","Redefines `self` with a definition-evaluating function…",0,[[]]],[11,"complexity","","",10,[[]]],[11,"get_const","","Gets the constant value stored in this expression, if any.",10,[[],["option",4]]],[11,"get_var","","Gets the variable value stored in this expression, if any.",10,[[],[["internedstr",3],["option",4]]]],[0,"transformer","libslide::grammar","",null,null],[8,"Transformer","libslide::grammar::transformer","A trait for transforming one grammar into another. This…",null,null],[10,"transform","","",28,[[]]],[8,"ExpressionTransformer","","A trait for transforming one expression into another.",null,null],[11,"transform","","",29,[[["rcexpr",3]],["rcexpr",3]]],[11,"transform_const","","",29,[[["span",3]],["rcexpr",3]]],[11,"transform_var","","",29,[[["span",3],["internedstr",3]],["rcexpr",3]]],[11,"transform_binary_op","","",29,[[["binaryoperator",4]],["binaryoperator",4]]],[11,"transform_binary","","",29,[[["span",3],["binaryexpr",3]],["rcexpr",3]]],[11,"transform_unary_op","","",29,[[["unaryoperator",4]],["unaryoperator",4]]],[11,"transform_unary","","",29,[[["span",3],["unaryexpr",3]],["rcexpr",3]]],[11,"transform_parend","","",29,[[["span",3],["rcexpr",3]],["rcexpr",3]]],[11,"transform_bracketed","","",29,[[["span",3],["rcexpr",3]],["rcexpr",3]]],[0,"visit","libslide::grammar","Traits for visiting slide grammar trees.",null,null],[5,"descend_stmt_list","libslide::grammar::visit","Descends down a statement list.",null,[[["stmtlist",3]]]],[5,"descend_stmt","","Descends down a statement.",null,[[["stmt",3]]]],[5,"descend_stmt_kind","","Descends down a specific statement kind.",null,[[["stmtkind",4]]]],[5,"descend_asgn","","Descends down an assignment.",null,[[["assignment",3]]]],[5,"descend_expr","","Descends down an expression.",null,[[["rcexpr",3]]]],[5,"descend_binary","","Descends down a binary expression.",null,[[["span",3],["binaryexpr",3]]]],[5,"descend_unary","","Descends down a unary expression.",null,[[["span",3],["unaryexpr",3]]]],[5,"descend_parend","","Descends down a parenthesized expression.",null,[[["span",3],["rcexpr",3]]]],[5,"descend_bracketed","","Descends down a bracketed expression.",null,[[["span",3],["rcexpr",3]]]],[5,"descend_expr_pat","","Descends down an expression pattern.",null,[[["rcexprpat",3]]]],[5,"descend_binary_expr_pat","","Descends down a binary expression pattern.",null,[[["binaryexpr",3]]]],[5,"descend_unary_expr_pat","","Descends down a unary expression pattern.",null,[[["unaryexpr",3]]]],[5,"descend_parend_expr_pat","","Descends down a parenthesized expression pattern.",null,[[["span",3],["rcexprpat",3]]]],[5,"descend_bracketed_expr_pat","","Descends down a bracketed expression pattern.",null,[[["span",3],["rcexprpat",3]]]],[8,"StmtVisitor","","Describes a statement list visitor.",null,null],[11,"visit_stmt_list","","Visits a statement list.",30,[[["stmtlist",3]]]],[11,"visit_stmt","","Visits a statement.",30,[[["stmt",3]]]],[11,"visit_stmt_kind","","Visits a specific statement kind.",30,[[["stmtkind",4]]]],[11,"visit_asgn","","Visits an assignment.",30,[[["assignment",3]]]],[11,"visit_asgn_op","","Visits an assignment operator.",30,[[["assignmentop",4]]]],[11,"visit_expr","","Visits an expression.",30,[[["rcexpr",3]]]],[11,"visit_const","","Visits a constant.",30,[[["span",3]]]],[11,"visit_var","","Visits a variable.",30,[[["span",3],["internedstr",3]]]],[11,"visit_binary_op","","Visits a binary operator.",30,[[["binaryoperator",4]]]],[11,"visit_binary","","Visits a binary expression.",30,[[["span",3],["binaryexpr",3]]]],[11,"visit_unary_op","","Visits a unary operator.",30,[[["unaryoperator",4]]]],[11,"visit_unary","","Visits a unary expression.",30,[[["span",3],["unaryexpr",3]]]],[11,"visit_parend","","Visits a parenthesized expression.",30,[[["span",3],["rcexpr",3]]]],[11,"visit_bracketed","","Visits a bracketed expression.",30,[[["span",3],["rcexpr",3]]]],[8,"ExprPatVisitor","","Describes an expression pattern visitor.",null,null],[11,"visit_expr_pat","","Visits an expression pattern.",31,[[["rcexprpat",3]]]],[11,"visit_const","","Visits a constant.",31,[[]]],[11,"visit_var_pat","","Visits a variable pattern.",31,[[["span",3]]]],[11,"visit_const_pat","","Visits a constant pattern.",31,[[["span",3]]]],[11,"visit_any_pat","","Visits an any pattern.",31,[[["span",3]]]],[11,"visit_binary_op","","Visits a binary operator.",31,[[["binaryoperator",4]]]],[11,"visit_binary_expr_pat","","Visits a binary expression pattern.",31,[[["binaryexpr",3]]]],[11,"visit_unary_op","","Visits a unary operator.",31,[[["unaryoperator",4]]]],[11,"visit_unary_expr_pat","","Visits a unary expression pattern.",31,[[["unaryexpr",3]]]],[11,"visit_parend_expr_pat","","Visits a parenthesized expression pattern.",31,[[["span",3],["rcexprpat",3]]]],[11,"visit_bracketed_expr_pat","","Visits a bracketed expression pattern.",31,[[["span",3],["rcexprpat",3]]]],[8,"Grammar","libslide::grammar","Describes a top-level item in the libslide grammar.",null,null],[11,"precedence","","",16,[[]]],[11,"is_associative","","",16,[[]]],[11,"sub","","",14,[[]]],[11,"mult","","",14,[[]]],[11,"div","","",14,[[]]],[11,"exp","","",14,[[]]],[11,"negate","","",15,[[]]],[0,"collectors","libslide","Module `collectors` provides utilities for collecting…",null,null],[5,"collect_var_names","libslide::collectors","Collects unique variable names in an expression.",null,[[["rcexpr",3]],[["internedstr",3],["hashset",3]]]],[5,"collect_var_asgns","","Collects variable assignments in a program.",null,[[["stmtlist",3]],[["vec",3],["internedstr",3],["hashmap",3]]]],[5,"collect_pat_names","","Collects unique pattern names in an pattern expression.",null,[[["rcexprpat",3]],["hashset",3]]],[0,"visit","libslide","Traits for visiting slide grammar trees.",null,null],[5,"descend_stmt_list","libslide::visit","Descends down a statement list.",null,[[["stmtlist",3]]]],[5,"descend_stmt","","Descends down a statement.",null,[[["stmt",3]]]],[5,"descend_stmt_kind","","Descends down a specific statement kind.",null,[[["stmtkind",4]]]],[5,"descend_asgn","","Descends down an assignment.",null,[[["assignment",3]]]],[5,"descend_expr","","Descends down an expression.",null,[[["rcexpr",3]]]],[5,"descend_binary","","Descends down a binary expression.",null,[[["span",3],["binaryexpr",3]]]],[5,"descend_unary","","Descends down a unary expression.",null,[[["span",3],["unaryexpr",3]]]],[5,"descend_parend","","Descends down a parenthesized expression.",null,[[["span",3],["rcexpr",3]]]],[5,"descend_bracketed","","Descends down a bracketed expression.",null,[[["span",3],["rcexpr",3]]]],[5,"descend_expr_pat","","Descends down an expression pattern.",null,[[["rcexprpat",3]]]],[5,"descend_binary_expr_pat","","Descends down a binary expression pattern.",null,[[["binaryexpr",3]]]],[5,"descend_unary_expr_pat","","Descends down a unary expression pattern.",null,[[["unaryexpr",3]]]],[5,"descend_parend_expr_pat","","Descends down a parenthesized expression pattern.",null,[[["span",3],["rcexprpat",3]]]],[5,"descend_bracketed_expr_pat","","Descends down a bracketed expression pattern.",null,[[["span",3],["rcexprpat",3]]]],[8,"StmtVisitor","","Describes a statement list visitor.",null,null],[11,"visit_stmt_list","libslide::grammar::visit","Visits a statement list.",30,[[["stmtlist",3]]]],[11,"visit_stmt","","Visits a statement.",30,[[["stmt",3]]]],[11,"visit_stmt_kind","","Visits a specific statement kind.",30,[[["stmtkind",4]]]],[11,"visit_asgn","","Visits an assignment.",30,[[["assignment",3]]]],[11,"visit_asgn_op","","Visits an assignment operator.",30,[[["assignmentop",4]]]],[11,"visit_expr","","Visits an expression.",30,[[["rcexpr",3]]]],[11,"visit_const","","Visits a constant.",30,[[["span",3]]]],[11,"visit_var","","Visits a variable.",30,[[["span",3],["internedstr",3]]]],[11,"visit_binary_op","","Visits a binary operator.",30,[[["binaryoperator",4]]]],[11,"visit_binary","","Visits a binary expression.",30,[[["span",3],["binaryexpr",3]]]],[11,"visit_unary_op","","Visits a unary operator.",30,[[["unaryoperator",4]]]],[11,"visit_unary","","Visits a unary expression.",30,[[["span",3],["unaryexpr",3]]]],[11,"visit_parend","","Visits a parenthesized expression.",30,[[["span",3],["rcexpr",3]]]],[11,"visit_bracketed","","Visits a bracketed expression.",30,[[["span",3],["rcexpr",3]]]],[8,"ExprPatVisitor","libslide::visit","Describes an expression pattern visitor.",null,null],[11,"visit_expr_pat","libslide::grammar::visit","Visits an expression pattern.",31,[[["rcexprpat",3]]]],[11,"visit_const","","Visits a constant.",31,[[]]],[11,"visit_var_pat","","Visits a variable pattern.",31,[[["span",3]]]],[11,"visit_const_pat","","Visits a constant pattern.",31,[[["span",3]]]],[11,"visit_any_pat","","Visits an any pattern.",31,[[["span",3]]]],[11,"visit_binary_op","","Visits a binary operator.",31,[[["binaryoperator",4]]]],[11,"visit_binary_expr_pat","","Visits a binary expression pattern.",31,[[["binaryexpr",3]]]],[11,"visit_unary_op","","Visits a unary operator.",31,[[["unaryoperator",4]]]],[11,"visit_unary_expr_pat","","Visits a unary expression pattern.",31,[[["unaryexpr",3]]]],[11,"visit_parend_expr_pat","","Visits a parenthesized expression pattern.",31,[[["span",3],["rcexprpat",3]]]],[11,"visit_bracketed_expr_pat","","Visits a bracketed expression pattern.",31,[[["span",3],["rcexprpat",3]]]],[0,"common","libslide","Common types used by libslide.",null,null],[3,"Span","libslide::common","Describes the character span of a substring in a text.",null,null],[12,"lo","","Inclusive lower bound index of the span, in terms of…",4,null],[12,"hi","","Exclusive upper bound index of the span, in terms of…",4,null],[3,"ProgramContext","","A context for evaluating a slide program.",null,null],[12,"rule_denylist","","Rules that should not be included in the evaluation of an…",5,null],[12,"always_flatten","","Whether an expression should always be flattened before it…",5,null],[12,"lint","","Whether \\\"lint\\\"-like diagnostics should be emitted.",5,null],[7,"DUMMY_SP","","A dummy span for use in places where a span is not (yet)…",null,null],[11,"to","libslide","",4,[[["span",3]],["span",3]]],[11,"over","","",4,[[]]],[11,"contains","","Returns `true` iff the span contains `pos`.",4,[[]]],[11,"with_denylist","","Set rules to exclude in evaluation.",5,[[]]],[11,"always_flatten","","Whether expressions should always be flattened during…",5,[[]]],[11,"lint","","Sets whether \\\"lint\\\"-like diagnostics should be emitted.",5,[[]]],[0,"diagnostics","","libslide\'s diagnostic module.",null,null],[3,"AssociatedDiagnostic","libslide::diagnostics","A secondary diagnostic associated with a primary…",null,null],[12,"kind","","The diagnostic kind.",32,null],[12,"span","","Source location for which the diagnostic is applicable.",32,null],[12,"msg","","Diagnostic message.",32,null],[3,"Diagnostic","","A diagnostic for slide source code.",null,null],[12,"kind","","The diagnostic kind.",33,null],[12,"code","","The diagnostic code.",33,null],[12,"span","","Source location for which the diagnostic is applicable.",33,null],[12,"title","","A summarizing title for the diagnostic.",33,null],[12,"msg","","Diagnostic message.",33,null],[12,"associated_diagnostics","","Any additional diagnostics associated with this one. The…",33,null],[12,"unspanned_associated_diagnostics","","Any additional diagnostics associated with this one, not…",33,null],[4,"DiagnosticKind","","The kind of a slide diagnostic.",null,null],[13,"Error","","An error diagnostic. Generally, this diagnostic should be…",34,null],[13,"Warning","","A warning diagnostic describes something that is not a…",34,null],[13,"Note","","A note diagnostic is a generic annotation with no specific…",34,null],[13,"Help","","A help diagnostic should instruct the user how their code…",34,null],[8,"DiagnosticRecord","","Describes a code and detailed explanation for a diagnostic.",null,null],[18,"CODE","","Diagnostic code.",35,null],[18,"EXPLANATION","","Detailed diagnostic explanation.",35,null],[8,"DiagnosticRegistry","","Describes an individual registry of slide diagnostics.",null,null],[10,"codes_with_explanations","","Retrieves all diagnostic codes owned by this registry and…",36,[[],["vec",3]]],[11,"span_err","","Creates an error diagnostic at a span.",33,[[],["diagnostic",3]]],[11,"span_warn","","Creates a warning diagnostic at a span.",33,[[],["diagnostic",3]]],[11,"with_note","","Adds a note to the diagnostic.",33,[[],["diagnostic",3]]],[11,"with_help","","Adds a help message to the diagnostic.",33,[[],["diagnostic",3]]],[11,"with_spanned_err","","Adds an error to the diagnostic, possibly at a different…",33,[[],["diagnostic",3]]],[11,"with_spanned_warn","","Adds a warning to the diagnostic, possibly at a different…",33,[[],["diagnostic",3]]],[11,"with_spanned_help","","Adds a help message to the diagnostic, possibly at a…",33,[[],["diagnostic",3]]],[11,"with_spanned_note","","Adds a note to the diagnostic, possibly at a different span.",33,[[],["diagnostic",3]]],[11,"all_codes_with_explanations","","All diagnostic codes and their explanations.",33,[[],["hashmap",3]]],[0,"scanner","libslide","Tokenizes slide programs and produces lexing diagnostics.",null,null],[3,"ScanErrors","libslide::scanner","Diagnostic errors produced by the scanner.",null,null],[3,"ScanResult","","Describes the result of tokenizing a slide program.",null,null],[12,"tokens","","Tokens of the program.",37,null],[12,"diagnostics","","Lexing diagnostics encountered while scanning the program.",37,null],[3,"Scanner","","",null,null],[12,"pos","","",38,null],[12,"input","","",38,null],[12,"leading_trivia_start","","",38,null],[12,"output","","",38,null],[12,"diagnostics","","",38,null],[5,"scan","","Scans and tokenizes a string-like slide program.",null,[[["into",8]],["scanresult",3]]],[0,"errors","","Diagnostic errors produced by the scanner.",null,null],[3,"InvalidToken","libslide::scanner::errors","Tokens in a slide program must be mathematically…",null,null],[3,"ScanErrors","","Diagnostic errors produced by the scanner.",null,null],[0,"types","libslide::scanner","Definitions of types used in the libslide scanner.",null,null],[3,"Token","libslide::scanner::types","Describes a token in a slide program.",null,null],[12,"ty","","The type of the token.",39,null],[12,"span","","The source span of the token.",39,null],[12,"full_span","","The full span of the token including its leading trivia.",39,null],[4,"TokenType","","The type of a Token.",null,null],[13,"Float","","Stores a scanned number in double precision.",40,null],[13,"Plus","","symbol",40,null],[13,"Minus","","symbol",40,null],[13,"Mult","","symbol",40,null],[13,"Div","","/ symbol",40,null],[13,"Mod","","% symbol",40,null],[13,"Exp","","^ symbol",40,null],[13,"Equal","","= symbol",40,null],[13,"AssignDefine","",":= symbol",40,null],[13,"OpenParen","","( symbol",40,null],[13,"CloseParen","",") symbol",40,null],[13,"OpenBracket","","[ symbol",40,null],[13,"CloseBracket","","] symbol",40,null],[13,"Variable","","A variable name.",40,null],[13,"VariablePattern","","A variable pattern, of form $name.",40,null],[13,"ConstPattern","","A constant pattern, of form #name.",40,null],[13,"AnyPattern","","An any pattern, of form _name.",40,null],[13,"Invalid","","An invalid token.",40,null],[13,"EOF","","End of file.",40,null],[11,"matcher","","",40,[[]]],[11,"new","","Creates a new token.",39,[[["tokentype",4]]]],[11,"new","libslide::scanner","Instantiate a new scanner.",38,[[],["scanner",3]]],[11,"peek","","",38,[[],["option",4]]],[11,"next","","",38,[[],["option",4]]],[11,"push_diag","","",38,[[["diagnostic",3]]]],[11,"push_tok","","",38,[[["span",3],["tokentype",4],["into",8]]]],[11,"collect_while","","",38,[[],["string",3]]],[11,"scan","","",38,[[]]],[11,"scan_trivia","","Scans leading trivia, including whitespace.",38,[[]]],[11,"scan_symbol","","Matches a symbol with a token and creates it.",38,[[]]],[11,"scan_num","","Scans through the content of a number to create a token of…",38,[[]]],[11,"scan_var_str","","",38,[[],["string",3]]],[11,"scan_var","","",38,[[]]],[11,"scan_var_pattern","","",38,[[]]],[11,"scan_const_pattern","","",38,[[]]],[11,"scan_any_pattern","","",38,[[]]],[0,"parser","libslide","Parses slide programs into the slide `grammar` IR and…",null,null],[3,"ParseResult","libslide::parser","Describes the result of parsing a slide program.",null,null],[12,"program","","The slide program.",6,null],[12,"diagnostics","","Parsing diagnostics encountered while scanning the program.",6,null],[5,"unclosed_delimiter","","Returns a diagnostic for an unclosed delimiter.",null,[[["token",3],["tt",4]],["diagnostic",3]]],[0,"errors","","Diagnostic errors produced by the parser.",null,null],[3,"ExtraTokens","libslide::parser::errors","This error fires on tokens that are not connected to the…",null,null],[3,"ExpectedExpr","","This error fires on token sequences that are expected to…",null,null],[3,"MismatchedClosingDelimiter","","All opening delimiters with closing pairs must have that…",null,null],[3,"IllegalPattern","","Patterns are illegal in a \\\"regular\\\" slide program; i.e. a…",null,null],[3,"IllegalVariable","","Variables are illegal in a slide expression pattern.",null,null],[3,"UnmatchedClosingDelimiter","","All closing delimiters with opening pairs must have that…",null,null],[3,"ParseErrors","","",null,null],[0,"expression_pattern_parser","libslide::parser","",null,null],[3,"ExpressionPatternParser","libslide::parser::expression_pattern_parser","",null,null],[12,"_input","","",41,null],[12,"diagnostics","","",41,null],[5,"parse","","Parses a tokenized slide expression pattern, emitting the…",null,[[["vec",3],["token",3]],[["rcexprpat",3],["parseresult",3]]]],[11,"new","","",41,[[["vec",3],["token",3]]]],[0,"statement_parser","libslide::parser","",null,null],[3,"ExpressionParser","libslide::parser::statement_parser","",null,null],[12,"_input","","",42,null],[12,"program","","",42,null],[12,"diagnostics","","",42,null],[5,"parse","","Parses a tokenized slide program, emitting the result and…",null,[[["vec",3],["token",3]],[["parseresult",3],["stmtlist",3]]]],[11,"new","","",42,[[["vec",3],["token",3]]]],[11,"parse_stmt","","",42,[[],["stmt",3]]],[11,"parse_pattern","","",42,[[["span",3],["string",3]],["rcexpr",3]]],[11,"peek_content","","Returns the full content of the current (peeked) token.",42,[[]]],[8,"Parser","libslide::parser","",null,null],[16,"Expr","","",43,null],[10,"input","","",43,[[],["peekiter",3]]],[10,"parse","","",43,[[]]],[10,"parse_float","","",43,[[["span",3]]]],[10,"parse_variable","","",43,[[["span",3],["string",3]]]],[10,"parse_var_pattern","","",43,[[["span",3],["string",3]]]],[10,"parse_const_pattern","","",43,[[["span",3],["string",3]]]],[10,"parse_any_pattern","","",43,[[["span",3],["string",3]]]],[11,"parse_open_paren","","",43,[[["token",3]]]],[11,"parse_open_bracket","","",43,[[["token",3]]]],[10,"push_diag","","",43,[[["diagnostic",3]]]],[10,"has_stmt_break","","",43,[[]]],[11,"done","","",43,[[]]],[11,"expr","","",43,[[]]],[11,"peek","","",43,[[],["token",3]]],[11,"next","","",43,[[],["token",3]]],[11,"add_sub_term","","",43,[[]]],[11,"mul_divide_mod_term","","",43,[[]]],[11,"exp_term","","",43,[[]]],[11,"num_term","","",43,[[]]],[11,"extra_tokens_diag","","Creates diagnostics for extra tokens following a primary…",43,[[]]],[0,"linter","libslide","Provides linter-like diagnostics for a slide program.",null,null],[3,"LintConfig","libslide::linter","Describes the configuration to use when linting a slide…",null,null],[12,"stmt_linters","","",44,null],[12,"expr_pat_linters","","",44,null],[5,"lint_stmt","","Lints a slide statement list.",null,[[["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[5,"lint_expr_pat","","Lints a slide expression pattern.",null,[[["rcexprpat",3]],[["diagnostic",3],["vec",3]]]],[0,"stmt","","Lints for a statement in a slide program.",null,null],[4,"StmtLintRule","libslide::linter::stmt","A lint rule applying to a statement in a slide program.",null,null],[13,"UnarySeriesLinter","","",45,null],[13,"RedundantNestingLinter","","",45,null],[13,"HomogenousAssignmentLinter","","",45,null],[0,"homogenous_assignment","","",null,null],[3,"HomogenousAssignmentLinter","libslide::linter::stmt::homogenous_assignment","",null,null],[12,"source","","",46,null],[12,"asgn_op","","The assignment op kind we expect to see across the…",46,null],[12,"diagnostics","","",46,null],[11,"new","","",46,[[]]],[0,"redundant_nesting","libslide::linter::stmt","",null,null],[3,"RedundantNestingLinter","libslide::linter::stmt::redundant_nesting","",null,null],[12,"source","","",47,null],[12,"diagnostics","","",47,null],[11,"new","","",47,[[]]],[11,"visit_nesting","","",47,[[["span",3],["rcexpr",3]]]],[0,"unary_series","libslide::linter::stmt","",null,null],[3,"UnarySeriesLinter","libslide::linter::stmt::unary_series","",null,null],[12,"source","","",48,null],[12,"diagnostics","","",48,null],[11,"new","","",48,[[]]],[11,"lint","libslide::linter::stmt","",45,[[["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[11,"all_explanations","","",45,[[],["vec",3]]],[0,"expr_pat","libslide::linter","Lints for an expression pattern in a slide program.",null,null],[4,"ExprPatLintRule","libslide::linter::expr_pat","A lint rule applying to a statement in a slide program.",null,null],[13,"SimilarNamesLinter","","",49,null],[0,"similar_names","","",null,null],[3,"NameCollection","libslide::linter::expr_pat::similar_names","",null,null],[12,"var_pat","","",50,null],[12,"const_pat","","",50,null],[12,"any_pat","","",50,null],[3,"SimilarNamesLinter","","",null,null],[12,"names","","",51,null],[4,"NameKind","","",null,null],[13,"Var","","",52,null],[13,"Const","","",52,null],[13,"Any","","",52,null],[11,"used_patterns","","",50,[[],[["namekind",4],["btreeset",3]]]],[11,"has_conflicts","","",50,[[]]],[11,"all_spans_sorted","","",50,[[],["vec",3]]],[11,"check_names","","",51,[[],[["diagnostic",3],["vec",3]]]],[11,"lint","libslide::linter::expr_pat","",49,[[["rcexprpat",3]],[["diagnostic",3],["vec",3]]]],[11,"all_explanations","","",49,[[],["vec",3]]],[8,"LintRule","libslide::linter","Describes a slide program linter. A `Linter` is…",null,null],[10,"lint","","Lints a grammar given the original source code of the…",53,[[],[["diagnostic",3],["vec",3]]]],[0,"partial_evaluator","libslide","libslide\'s heavy-lifting optimizer, applying…",null,null],[3,"EvaluationResult","libslide::partial_evaluator","Describes the result of a slide program evaluation.",null,null],[12,"simplified","","Input program statements, evaluated to as simple a form…",7,null],[12,"diagnostics","","Diagnostic",7,null],[5,"evaluate","","Evaluates a list of statements to as simplified a form as…",null,[[["stmtlist",3],["programcontext",3]],[["box",3],["evaluationresult",3],["result",4]]]],[5,"evaluate_expr","","Evaluates an expression to as simplified a form as…",null,[[["rcexpr",3],["programcontext",3]],["rcexpr",3]]],[5,"build_rules","","Given an evaluator context, builds a set of evaluator…",null,[[["programcontext",3]],[["buildruleerrors",3],["result",4],["vec",3]]]],[0,"errors","","Diagnostic errors produced by the partial evaluator.",null,null],[3,"IncompatibleDefinitions","libslide::partial_evaluator::errors","This error is fired on variable definitions provided to a…",null,null],[3,"MaybeIncompatibleDefinitions","","This warning is fired on variable definitions that may be…",null,null],[3,"PartialEvaluatorErrors","","",null,null],[0,"compare","libslide::partial_evaluator","Module `compare` compares expressions for equality.",null,null],[4,"EqRelation","libslide::partial_evaluator::compare","Describes the equivalence relation between two expressions.",null,null],[13,"AlwaysEquivalent","","The expressions are always equivalent.",54,null],[13,"NeverEquivalent","","The expressions are never equivalent.",54,null],[13,"DependsOn","","The equality of the two expressions depends on some…",54,null],[5,"cmp_eq","","Compares two expressions for equivalence, returning an…",null,[[["programcontext",3],["rcexpr",3]],["eqrelation",4]]],[0,"flatten","libslide::partial_evaluator","This module tries to flatten expressions as far as…",null,null],[5,"flatten_expr","libslide::partial_evaluator::flatten","Attempts to flatten an expression, folding constant…",null,[[["rcexpr",3]],["rcexpr",3]]],[5,"flatten_add_or_sub","","Flattens an addition or subtraction, folding constants and…",null,[[["rcexpr",3]],["rcexpr",3]]],[5,"flatten_mul_or_div","","Flattens a multiplication or division, folding constants…",null,[[["rcexpr",3]],["rcexpr",3]]],[5,"unwrap_expr","","Unwraps an expression in parentheses/brackets, or returns…",null,[[["rcexpr",3]],["rcexpr",3]]],[0,"validate","libslide::partial_evaluator","Validates that evaluated slide programs are well-formed.…",null,null],[4,"PEValidator","libslide::partial_evaluator::validate","",null,null],[13,"IncompatibleDefinitionsValidator","","",55,null],[5,"validate","","",null,[[["programcontext",3],["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[0,"incompatible_definitions","","Detects incompatible variable definitions in a slide…",null,null],[3,"IncompatibleDefinitionsValidator","libslide::partial_evaluator::validate::incompatible_definitions","",null,null],[5,"all_ordered_definition_pairs","","",null,[[["vec",3],["internedstr",3],["hashmap",3]],["vec",3]]],[5,"validate","","",null,[[["programcontext",3],["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[7,"MAX_DEFINITION_PAIRS","","Max number of definition pairs we generate diagnostics for.",null,null],[8,"Validator","libslide::partial_evaluator::validate","",null,null],[10,"validate","","",56,[[["programcontext",3],["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[11,"validate","","",55,[[["programcontext",3],["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[0,"variable_expand","libslide::partial_evaluator","This module expands variables in expressions to their…",null,null],[3,"EagerVariableExpander","libslide::partial_evaluator::variable_expand","Eagerly expands variables in an expression.",null,null],[12,"expr","","",57,null],[12,"expand_def","","",57,null],[3,"LazyVariableExpander","","Lazily expands variables in an expression.",null,null],[12,"expr","","",58,null],[12,"expand_defs","","",58,null],[8,"VariableExpander","","",null,null],[10,"new","","Creates a new VariableExpander from an expression to expand.",59,[[["rcexpr",3]]]],[10,"expand","","Expands the variables matching the lhs of `asgn` with the…",59,[[["assignment",3]]]],[10,"finish","","Consumes `self` and returns the owned expression with any…",59,[[],["rcexpr",3]]],[0,"evaluator_rules","libslide","Grammar->Grammar transforming rules, used by the…",null,null],[0,"pattern_match","libslide::evaluator_rules","",null,null],[3,"PatternMatch","libslide::evaluator_rules::pattern_match","Represents pattern-matched replacements betwen a rule and…",null,null],[12,"map","","",60,null],[8,"MatchRule","","",null,null],[10,"match_rule","","Pattern matches a rule template against an expression. If…",61,[[["rcexprpat",3]],[["patternmatch",3],["option",4]]]],[11,"try_merge","","Merges two `PatternMatch`. If the `PatternMatch` are of…",60,[[["patternmatch",3]],[["patternmatch",3],["option",4]]]],[11,"insert","","",60,[[["rcexprpat",3]],["option",4]]],[0,"registry","libslide::evaluator_rules","",null,null],[3,"RuleSet","libslide::evaluator_rules::registry","Set of unbuilt rules.",null,null],[12,"rules","","",62,null],[12,"custom_rules","","",62,null],[3,"BuildRuleErrors","","",null,null],[12,"errors","","",63,null],[4,"RuleName","","",null,null],[13,"UnwrapExplicitParens","","",64,null],[13,"UnwrapExplicitBrackets","","",64,null],[13,"Add","","",64,null],[13,"Subtract","","",64,null],[13,"Multiply","","",64,null],[13,"Divide","","",64,null],[13,"Modulo","","",64,null],[13,"Exponentiate","","",64,null],[13,"Posate","","",64,null],[13,"Negate","","",64,null],[13,"MultiplicateIdentity","","",64,null],[13,"AdditiveIdentity","","",64,null],[13,"AdditiveInverse","","",64,null],[13,"SubtractiveIdentity","","",64,null],[13,"ReorderConstants","","",64,null],[13,"DistributeNegation","","",64,null],[13,"FoldNegatedAddition","","",64,null],[13,"FoldDivision","","",64,null],[13,"FoldExponents","","",64,null],[13,"ExponentiativeIdentity","","",64,null],[5,"get_all_rules","","",null,[[],[["hashmap",3],["rulename",4],["unbuiltrule",4]]]],[0,"fn_rules","","",null,null],[5,"add","libslide::evaluator_rules::registry::fn_rules","",null,[[["rcexpr",3]],[["rcexpr",3],["option",4]]]],[5,"subtract","","",null,[[["rcexpr",3]],[["rcexpr",3],["option",4]]]],[5,"multiply","","",null,[[["rcexpr",3]],[["rcexpr",3],["option",4]]]],[5,"divide","","",null,[[["rcexpr",3]],[["rcexpr",3],["option",4]]]],[5,"modulo","","",null,[[["rcexpr",3]],[["rcexpr",3],["option",4]]]],[5,"exponentiate","","",null,[[["rcexpr",3]],[["rcexpr",3],["option",4]]]],[5,"posate","","",null,[[["rcexpr",3]],[["rcexpr",3],["option",4]]]],[5,"negate","","",null,[[["rcexpr",3]],[["rcexpr",3],["option",4]]]],[11,"build","libslide::evaluator_rules::registry","Creates a list of `Rules`s from the unbuilt rule set.",62,[[],[["buildruleerrors",3],["result",4],["vec",3]]]],[11,"remove","","Remove a named rule from the rule set.",62,[[["rulename",4]]]],[11,"insert_custom","","Insert a custom unbuilt rule into the rule set.",62,[[["into",8],["unbuiltrule",4]]]],[11,"get_bootstrapping_rules","","Retrieves a set of rules to be used in bootstrapping other…",62,[[],[["rule",4],["vec",3]]]],[11,"get_boostrap_blacklist","","Retrieves a set of rules to be excluded from being…",62,[[],[["hashset",3],["option",4]]]],[0,"rule","libslide::evaluator_rules","",null,null],[3,"PatternMap","libslide::evaluator_rules::rule","A mapping between two expression patterns.",null,null],[12,"from","","",65,null],[12,"to","","",65,null],[3,"UnresolvedMapping","","",null,null],[12,"map","","",66,null],[12,"unresolved_pats","","",66,null],[4,"Rule","","",null,null],[13,"PatternMap","","",67,null],[13,"Evaluate","","",67,null],[5,"fn_name","","",null,[[]]],[11,"from_str","","Converts a string representation of a rule to a…",65,[[]]],[11,"bootstrap","","Bootstraps a `PatternMap` rule with a one-pass application…",65,[[]]],[11,"validate","","Checks a `PatternMap` is resolvable, returning an error if…",65,[[],[["result",4],["unresolvedmapping",3]]]],[11,"from_fn","","",67,[[]]],[11,"from_str","","",67,[[]]],[0,"unbuilt_rule","libslide::evaluator_rules","",null,null],[4,"UnbuiltRule","libslide::evaluator_rules::unbuilt_rule","An unbuilt rule, generally used to express a rule in a…",null,null],[13,"S","","An expression-mapping rule.",68,null],[13,"M","","Multiple string rules. This should be used by rules that…",68,null],[13,"F","","A function rule.",68,null],[0,"math","libslide","A collection of algorithms used by evaluation rules.",null,null],[0,"fraction","libslide::math","",null,null],[3,"Dec2FracError","libslide::math::fraction","",null,null],[12,"num_iter","","",69,null],[12,"decimal_error","","",69,null],[5,"dec2frac","","Converts a decimal number to its irreducible fractional…",null,[[],[["dec2fracerror",3],["result",4]]]],[6,"Fraction","","Represents a fraction, consisting of a numerator and…",null,null],[0,"gcd","libslide::math","",null,null],[5,"gcd","libslide::math::gcd","Calculates the GCD for (u, v) ∈ (Z, Z).",null,[[["primint",8],["unsigned",8]],[["primint",8],["unsigned",8]]]],[5,"binary_gcd","","The Binary GCD algorithm, or Stein\'s algorithm.…",null,[[["primint",8],["unsigned",8]],[["primint",8],["unsigned",8]]]],[5,"euclidean_gcd","","The Euclidean GCD algorithm. Implemented ∀ (u, v) ∈ (Z, Z).",null,[[["primint",8],["unsigned",8]],[["primint",8],["unsigned",8]]]],[0,"poly","libslide::math","",null,null],[3,"Poly","libslide::math::poly","A polynomial in integer space Z. TODO: Currently, this…",null,null],[12,"vec","","Underlying polynomial coefficient representation. The…",8,null],[5,"term_and_pow_from_expr","","Gets the term and power of an expression. Returns None if…",null,[[["rcexpr",3]],[["result",4],["string",3]]]],[11,"new","libslide","Creates a new Poly from a vector of coefficients, with the…",8,[[["vec",3]]]],[11,"empty","","Creates an empty Poly.",8,[[]]],[11,"is_zero","","Returns whether the polynomial is equivalent to 0.",8,[[]]],[11,"is_one","","Returns whether the polynomial is equivalent to 1.",8,[[]]],[11,"deg","","Returns the degree of the polynomial.",8,[[]]],[11,"primitive","","Returns the primitive polynomial of `self` over the…",8,[[]]],[11,"add_term","","Adds a term of form `coeff`x^`pow` to `self`.",8,[[]]],[11,"mul_term","","Multiplies a term of form `coeff`x^`pow` to `self`.",8,[[]]],[11,"mul_scalar","","Multiplies each term in the polynomial by a scalar.",8,[[]]],[11,"div_scalar","","Divides each term in the polynomial by a scalar. If the…",8,[[],["result",4]]],[11,"sub","","Subtracts `other` from `self`, yielding a new polynomial.",8,[[]]],[11,"truncate_zeros","","Removes leading zero terms in a polynomial.",8,[[]]],[11,"div","","Divides one polynomial by another, returning a tuple of…",8,[[["poly",3]],["result",4]]],[11,"max_norm","","Returns the max norm of a polynomial. This is equivalent…",8,[[]]],[11,"lc","","Returns the leading coefficient, i.e. the coefficient of…",8,[[]]],[11,"eval","","Evaluates the polynomial at a value `x`.",8,[[]]],[11,"from_expr","","Transforms an expression into a polynomial relative to…",8,[[["rcexpr",3],["option",4]],[["result",4],["string",3]]]],[11,"to_expr","","Converts a Poly polynomial, relative to some term, into an…",8,[[["rcexpr",3],["span",3]],["rcexpr",3]]],[11,"to_string","","Prints the Poly as a polynomial string.",8,[[],["string",3]]],[0,"gcd_poly_zz","libslide::math","",null,null],[5,"gcd_poly_zz_heu","libslide::math::gcd_poly_zz","Calculates the GCD of two polynomials, `f` and `g`, in ZZ…",null,[[["poly",3]],["result",4]]],[5,"poly_coeffs_gcd","","Returns the GCD of a polynomial\'s term coefficients.",null,[[["poly",3]]]],[5,"poly_extract_common","","Extracts a constant coefficient from two polynomials.…",null,[[["poly",3]]]],[5,"trivial_gcd","","Handles trivial polynomial GCD cases, namely if one…",null,[[["poly",3]],["option",4]]],[5,"gcd_interpolate","","Interpolates step-wise gcd of h and x into a polynomial.",null,[[],["poly",3]]],[0,"emit","libslide","Emit strategies for the libslide grammar IR.",null,null],[3,"EmitConfig","libslide::emit","Configuration options for emitting a slide grammar.",null,null],[12,"bits","","",9,null],[4,"EmitFormat","","The format in which a slide grammar should be emitted.",null,null],[13,"Pretty","","Canonical, human-readable form. For example, `1+1` is…",13,null],[13,"SExpression","","S-expression form. For example, `1+1` is output as `(+ 1…",13,null],[13,"Latex","","LaTeX output form. For example, `(1 + 1)` is output as…",13,null],[13,"Debug","","Slide internal debug form. NB: this form is not stable,…",13,null],[5,"emit_pretty","","",null,[[["emitconfig",3]],["string",3]]],[5,"emit_latex","","",null,[[["emitconfig",3]],["string",3]]],[5,"join_emits","","",null,[[],["string",3]]],[5,"vert_lines","","",null,[[],["string",3]]],[8,"Emit","","Implements the emission of a type in an EmitFormat.",null,null],[11,"emit","","Emit `self` with the given EmitFormat.",70,[[["emitformat",4],["emitconfig",3]],["string",3]]],[10,"emit_pretty","","Emit `self` with the pretty emit format",70,[[["emitconfig",3]],["string",3]]],[11,"emit_debug","","Emit `self` with the debug emit format",70,[[["emitconfig",3]],["string",3]]],[10,"emit_s_expression","","Emit `self` with the s_expression emit format",70,[[["emitconfig",3]],["string",3]]],[10,"emit_latex","","Emit `self` with the LaTeX emit format",70,[[["emitconfig",3]],["string",3]]],[11,"emit_wrapped_latex","","Same as emit_latex, but wraps the latex code in inline…",70,[[["emitconfig",3]],["string",3]]],[18,"FRAC","libslide","Emit divisions as fractions. Applies to LaTeX emit.",9,null],[18,"IMPLICIT_MULT","","Emits multiplications implicitly where possible. For…",9,null],[18,"TIMES","","Emits multiplication signs as \\\"\\\\times\\\". Applies to LaTeX…",9,null],[18,"DIV","","Emits divisions as \\\"\\\\div\\\". Applies to LaTeX emit.",9,null],[11,"empty","","Returns an empty set of flags",9,[[],["emitconfig",3]]],[11,"all","","Returns the set containing all flags.",9,[[],["emitconfig",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",9,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",9,[[],[["option",4],["emitconfig",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",9,[[],["emitconfig",3]]],[11,"from_bits_unchecked","","Convert from underlying bit representation, preserving all…",9,[[],["emitconfig",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",9,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",9,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",9,[[["emitconfig",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",9,[[["emitconfig",3]]]],[11,"insert","","Inserts the specified flags in-place.",9,[[["emitconfig",3]]]],[11,"remove","","Removes the specified flags in-place.",9,[[["emitconfig",3]]]],[11,"toggle","","Toggles the specified flags in-place.",9,[[["emitconfig",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",9,[[["emitconfig",3]]]],[0,"utils","","Library utilities.",null,null],[0,"grammar","libslide::utils","",null,null],[4,"UnflattenStrategy","libslide::utils::grammar","",null,null],[13,"Left","","",71,null],[13,"Right","","",71,null],[5,"get_symmetric_expressions","","",null,[[["rcexpr",3]],[["vec",3],["rcexpr",3]]]],[5,"get_flattened_binary_args","","",null,[[["rcexpr",3],["binaryoperator",4]],[["vec",3],["rcexpr",3]]]],[5,"negate","","",null,[[["rcexpr",3]],["rcexpr",3]]],[5,"unflatten_binary_expr","","",null,[[["unflattenstrategy",4],["binaryoperator",4]]]],[5,"normalize","","",null,[[["rcexpr",3]],["rcexpr",3]]],[0,"hash","libslide::utils","",null,null],[5,"hash","libslide::utils::hash","",null,[[]]],[0,"iter","libslide::utils","",null,null],[3,"PeekingTakeWhile","libslide::utils::iter","A `TakeWhile`-like struct that tests a predicate by…",null,null],[12,"peeker","","A mutable reference to the underlying iterator is taken…",72,null],[12,"predicate","","",72,null],[3,"PeekIter","","An iterator that supports arbitrary-length peeking.",null,null],[12,"iter","","",73,null],[12,"lookahead","","A store of items we had to consume from the iterator for…",73,null],[11,"new","","",73,[[["intoiter",3]]]],[11,"peek","","Returns a reference to the next value in the iterator,…",73,[[],["option",4]]],[11,"peek_map_n","","Returns a deque of up to `n` peeked items mapped over a…",73,[[],["vecdeque",3]]],[11,"push_front","","Adds an item to the front of the current iteration.",73,[[]]],[0,"string","libslide::utils","",null,null],[5,"indent","libslide::utils::string","Indents all lines of a string with `n` spaces.",null,[[["into",8],["string",3]],["string",3]]],[8,"StringUtils","","",null,null],[10,"substring","","",74,[[]]],[0,"test","libslide::utils","",null,null],[8,"Grammar","libslide","Describes a top-level item in the libslide grammar.",null,null],[8,"Emit","","Implements the emission of a type in an EmitFormat.",null,null],[11,"emit","libslide::emit","Emit `self` with the given EmitFormat.",70,[[["emitformat",4],["emitconfig",3]],["string",3]]],[10,"emit_pretty","libslide","Emit `self` with the pretty emit format",70,[[["emitconfig",3]],["string",3]]],[11,"emit_debug","libslide::emit","Emit `self` with the debug emit format",70,[[["emitconfig",3]],["string",3]]],[10,"emit_s_expression","libslide","Emit `self` with the s_expression emit format",70,[[["emitconfig",3]],["string",3]]],[10,"emit_latex","","Emit `self` with the LaTeX emit format",70,[[["emitconfig",3]],["string",3]]],[11,"emit_wrapped_latex","libslide::emit","Same as emit_latex, but wraps the latex code in inline…",70,[[["emitconfig",3]],["string",3]]],[14,"intern_str","libslide","Interns a string.",null,null],[14,"rc_expr","","Interns an expression.",null,null],[14,"rc_expr_pat","","Interns an expression.",null,null],[14,"poly","","Creates a new Poly.",null,null],[14,"parse_stmt","","Parses a statement.",null,null],[14,"parse_expr","","Parses an expression.",null,null],[14,"parse_asgn","","Parses an assignment.",null,null],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"to_string","","",1,[[],["string",3]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"to_string","","",2,[[],["string",3]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"into_iter","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"to_string","","",3,[[],["string",3]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"to_string","","",10,[[],["string",3]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"to_string","","",11,[[],["string",3]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"to_string","","",12,[[],["string",3]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","libslide::grammar","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"to_string","","",14,[[],["string",3]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from","","",15,[[]]],[11,"into","","",15,[[]]],[11,"to_owned","","",15,[[]]],[11,"clone_into","","",15,[[]]],[11,"to_string","","",15,[[],["string",3]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"from","","",16,[[]]],[11,"into","","",16,[[]]],[11,"to_owned","","",16,[[]]],[11,"clone_into","","",16,[[]]],[11,"to_string","","",16,[[],["string",3]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"from","","",17,[[]]],[11,"into","","",17,[[]]],[11,"to_owned","","",17,[[]]],[11,"clone_into","","",17,[[]]],[11,"to_string","","",17,[[],["string",3]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from","libslide::grammar::mem","",18,[[]]],[11,"into","","",18,[[]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from","","",19,[[]]],[11,"into","","",19,[[]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","","",20,[[]]],[11,"into","","",20,[[]]],[11,"to_owned","","",20,[[]]],[11,"clone_into","","",20,[[]]],[11,"to_string","","",20,[[],["string",3]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from","","",21,[[]]],[11,"into","","",21,[[]]],[11,"to_owned","","",21,[[]]],[11,"clone_into","","",21,[[]]],[11,"to_string","","",21,[[],["string",3]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from","libslide::grammar::collectors","",23,[[]]],[11,"into","","",23,[[]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","","",24,[[]]],[11,"into","","",24,[[]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"try_into","","",24,[[],["result",4]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"from","","",25,[[]]],[11,"into","","",25,[[]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"try_into","","",25,[[],["result",4]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"from","libslide::grammar::statement","",26,[[]]],[11,"into","","",26,[[]]],[11,"into_iter","","",26,[[]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from","","",27,[[]]],[11,"into","","",27,[[]]],[11,"to_owned","","",27,[[]]],[11,"clone_into","","",27,[[]]],[11,"to_string","","",27,[[],["string",3]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"from","libslide::diagnostics","",32,[[]]],[11,"into","","",32,[[]]],[11,"borrow","","",32,[[]]],[11,"borrow_mut","","",32,[[]]],[11,"try_from","","",32,[[],["result",4]]],[11,"try_into","","",32,[[],["result",4]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"from","","",33,[[]]],[11,"into","","",33,[[]]],[11,"borrow","","",33,[[]]],[11,"borrow_mut","","",33,[[]]],[11,"try_from","","",33,[[],["result",4]]],[11,"try_into","","",33,[[],["result",4]]],[11,"type_id","","",33,[[],["typeid",3]]],[11,"from","","",34,[[]]],[11,"into","","",34,[[]]],[11,"borrow","","",34,[[]]],[11,"borrow_mut","","",34,[[]]],[11,"try_from","","",34,[[],["result",4]]],[11,"try_into","","",34,[[],["result",4]]],[11,"type_id","","",34,[[],["typeid",3]]],[11,"from","libslide::scanner","",75,[[]]],[11,"into","","",75,[[]]],[11,"borrow","","",75,[[]]],[11,"borrow_mut","","",75,[[]]],[11,"try_from","","",75,[[],["result",4]]],[11,"try_into","","",75,[[],["result",4]]],[11,"type_id","","",75,[[],["typeid",3]]],[11,"from","","",37,[[]]],[11,"into","","",37,[[]]],[11,"borrow","","",37,[[]]],[11,"borrow_mut","","",37,[[]]],[11,"try_from","","",37,[[],["result",4]]],[11,"try_into","","",37,[[],["result",4]]],[11,"type_id","","",37,[[],["typeid",3]]],[11,"from","","",38,[[]]],[11,"into","","",38,[[]]],[11,"borrow","","",38,[[]]],[11,"borrow_mut","","",38,[[]]],[11,"try_from","","",38,[[],["result",4]]],[11,"try_into","","",38,[[],["result",4]]],[11,"type_id","","",38,[[],["typeid",3]]],[11,"from","libslide::scanner::errors","",76,[[]]],[11,"into","","",76,[[]]],[11,"borrow","","",76,[[]]],[11,"borrow_mut","","",76,[[]]],[11,"try_from","","",76,[[],["result",4]]],[11,"try_into","","",76,[[],["result",4]]],[11,"type_id","","",76,[[],["typeid",3]]],[11,"from","libslide::scanner::types","",39,[[]]],[11,"into","","",39,[[]]],[11,"to_owned","","",39,[[]]],[11,"clone_into","","",39,[[]]],[11,"to_string","","",39,[[],["string",3]]],[11,"borrow","","",39,[[]]],[11,"borrow_mut","","",39,[[]]],[11,"try_from","","",39,[[],["result",4]]],[11,"try_into","","",39,[[],["result",4]]],[11,"type_id","","",39,[[],["typeid",3]]],[11,"from","","",40,[[]]],[11,"into","","",40,[[]]],[11,"to_owned","","",40,[[]]],[11,"clone_into","","",40,[[]]],[11,"to_string","","",40,[[],["string",3]]],[11,"borrow","","",40,[[]]],[11,"borrow_mut","","",40,[[]]],[11,"try_from","","",40,[[],["result",4]]],[11,"try_into","","",40,[[],["result",4]]],[11,"type_id","","",40,[[],["typeid",3]]],[11,"from","libslide::parser::errors","",77,[[]]],[11,"into","","",77,[[]]],[11,"borrow","","",77,[[]]],[11,"borrow_mut","","",77,[[]]],[11,"try_from","","",77,[[],["result",4]]],[11,"try_into","","",77,[[],["result",4]]],[11,"type_id","","",77,[[],["typeid",3]]],[11,"from","","",78,[[]]],[11,"into","","",78,[[]]],[11,"borrow","","",78,[[]]],[11,"borrow_mut","","",78,[[]]],[11,"try_from","","",78,[[],["result",4]]],[11,"try_into","","",78,[[],["result",4]]],[11,"type_id","","",78,[[],["typeid",3]]],[11,"from","","",79,[[]]],[11,"into","","",79,[[]]],[11,"borrow","","",79,[[]]],[11,"borrow_mut","","",79,[[]]],[11,"try_from","","",79,[[],["result",4]]],[11,"try_into","","",79,[[],["result",4]]],[11,"type_id","","",79,[[],["typeid",3]]],[11,"from","","",80,[[]]],[11,"into","","",80,[[]]],[11,"borrow","","",80,[[]]],[11,"borrow_mut","","",80,[[]]],[11,"try_from","","",80,[[],["result",4]]],[11,"try_into","","",80,[[],["result",4]]],[11,"type_id","","",80,[[],["typeid",3]]],[11,"from","","",81,[[]]],[11,"into","","",81,[[]]],[11,"borrow","","",81,[[]]],[11,"borrow_mut","","",81,[[]]],[11,"try_from","","",81,[[],["result",4]]],[11,"try_into","","",81,[[],["result",4]]],[11,"type_id","","",81,[[],["typeid",3]]],[11,"from","","",82,[[]]],[11,"into","","",82,[[]]],[11,"borrow","","",82,[[]]],[11,"borrow_mut","","",82,[[]]],[11,"try_from","","",82,[[],["result",4]]],[11,"try_into","","",82,[[],["result",4]]],[11,"type_id","","",82,[[],["typeid",3]]],[11,"from","","",83,[[]]],[11,"into","","",83,[[]]],[11,"borrow","","",83,[[]]],[11,"borrow_mut","","",83,[[]]],[11,"try_from","","",83,[[],["result",4]]],[11,"try_into","","",83,[[],["result",4]]],[11,"type_id","","",83,[[],["typeid",3]]],[11,"from","libslide::parser::expression_pattern_parser","",41,[[]]],[11,"into","","",41,[[]]],[11,"borrow","","",41,[[]]],[11,"borrow_mut","","",41,[[]]],[11,"try_from","","",41,[[],["result",4]]],[11,"try_into","","",41,[[],["result",4]]],[11,"type_id","","",41,[[],["typeid",3]]],[11,"from","libslide::parser::statement_parser","",42,[[]]],[11,"into","","",42,[[]]],[11,"borrow","","",42,[[]]],[11,"borrow_mut","","",42,[[]]],[11,"try_from","","",42,[[],["result",4]]],[11,"try_into","","",42,[[],["result",4]]],[11,"type_id","","",42,[[],["typeid",3]]],[11,"from","libslide::linter","",44,[[]]],[11,"into","","",44,[[]]],[11,"borrow","","",44,[[]]],[11,"borrow_mut","","",44,[[]]],[11,"try_from","","",44,[[],["result",4]]],[11,"try_into","","",44,[[],["result",4]]],[11,"type_id","","",44,[[],["typeid",3]]],[11,"from","libslide::linter::stmt","",45,[[]]],[11,"into","","",45,[[]]],[11,"borrow","","",45,[[]]],[11,"borrow_mut","","",45,[[]]],[11,"try_from","","",45,[[],["result",4]]],[11,"try_into","","",45,[[],["result",4]]],[11,"type_id","","",45,[[],["typeid",3]]],[11,"from","libslide::linter::stmt::homogenous_assignment","",46,[[]]],[11,"into","","",46,[[]]],[11,"borrow","","",46,[[]]],[11,"borrow_mut","","",46,[[]]],[11,"try_from","","",46,[[],["result",4]]],[11,"try_into","","",46,[[],["result",4]]],[11,"type_id","","",46,[[],["typeid",3]]],[11,"from","libslide::linter::stmt::redundant_nesting","",47,[[]]],[11,"into","","",47,[[]]],[11,"borrow","","",47,[[]]],[11,"borrow_mut","","",47,[[]]],[11,"try_from","","",47,[[],["result",4]]],[11,"try_into","","",47,[[],["result",4]]],[11,"type_id","","",47,[[],["typeid",3]]],[11,"from","libslide::linter::stmt::unary_series","",48,[[]]],[11,"into","","",48,[[]]],[11,"borrow","","",48,[[]]],[11,"borrow_mut","","",48,[[]]],[11,"try_from","","",48,[[],["result",4]]],[11,"try_into","","",48,[[],["result",4]]],[11,"type_id","","",48,[[],["typeid",3]]],[11,"from","libslide::linter::expr_pat","",49,[[]]],[11,"into","","",49,[[]]],[11,"borrow","","",49,[[]]],[11,"borrow_mut","","",49,[[]]],[11,"try_from","","",49,[[],["result",4]]],[11,"try_into","","",49,[[],["result",4]]],[11,"type_id","","",49,[[],["typeid",3]]],[11,"from","libslide::linter::expr_pat::similar_names","",50,[[]]],[11,"into","","",50,[[]]],[11,"borrow","","",50,[[]]],[11,"borrow_mut","","",50,[[]]],[11,"try_from","","",50,[[],["result",4]]],[11,"try_into","","",50,[[],["result",4]]],[11,"type_id","","",50,[[],["typeid",3]]],[11,"from","","",51,[[]]],[11,"into","","",51,[[]]],[11,"borrow","","",51,[[]]],[11,"borrow_mut","","",51,[[]]],[11,"try_from","","",51,[[],["result",4]]],[11,"try_into","","",51,[[],["result",4]]],[11,"type_id","","",51,[[],["typeid",3]]],[11,"from","","",52,[[]]],[11,"into","","",52,[[]]],[11,"to_string","","",52,[[],["string",3]]],[11,"borrow","","",52,[[]]],[11,"borrow_mut","","",52,[[]]],[11,"try_from","","",52,[[],["result",4]]],[11,"try_into","","",52,[[],["result",4]]],[11,"type_id","","",52,[[],["typeid",3]]],[11,"from","libslide::partial_evaluator::errors","",84,[[]]],[11,"into","","",84,[[]]],[11,"borrow","","",84,[[]]],[11,"borrow_mut","","",84,[[]]],[11,"try_from","","",84,[[],["result",4]]],[11,"try_into","","",84,[[],["result",4]]],[11,"type_id","","",84,[[],["typeid",3]]],[11,"from","","",85,[[]]],[11,"into","","",85,[[]]],[11,"borrow","","",85,[[]]],[11,"borrow_mut","","",85,[[]]],[11,"try_from","","",85,[[],["result",4]]],[11,"try_into","","",85,[[],["result",4]]],[11,"type_id","","",85,[[],["typeid",3]]],[11,"from","","",86,[[]]],[11,"into","","",86,[[]]],[11,"borrow","","",86,[[]]],[11,"borrow_mut","","",86,[[]]],[11,"try_from","","",86,[[],["result",4]]],[11,"try_into","","",86,[[],["result",4]]],[11,"type_id","","",86,[[],["typeid",3]]],[11,"from","libslide::partial_evaluator::compare","",54,[[]]],[11,"into","","",54,[[]]],[11,"borrow","","",54,[[]]],[11,"borrow_mut","","",54,[[]]],[11,"try_from","","",54,[[],["result",4]]],[11,"try_into","","",54,[[],["result",4]]],[11,"type_id","","",54,[[],["typeid",3]]],[11,"from","libslide::partial_evaluator::validate","",55,[[]]],[11,"into","","",55,[[]]],[11,"borrow","","",55,[[]]],[11,"borrow_mut","","",55,[[]]],[11,"try_from","","",55,[[],["result",4]]],[11,"try_into","","",55,[[],["result",4]]],[11,"type_id","","",55,[[],["typeid",3]]],[11,"from","libslide::partial_evaluator::validate::incompatible_definitions","",87,[[]]],[11,"into","","",87,[[]]],[11,"borrow","","",87,[[]]],[11,"borrow_mut","","",87,[[]]],[11,"try_from","","",87,[[],["result",4]]],[11,"try_into","","",87,[[],["result",4]]],[11,"type_id","","",87,[[],["typeid",3]]],[11,"from","libslide::partial_evaluator::variable_expand","",57,[[]]],[11,"into","","",57,[[]]],[11,"borrow","","",57,[[]]],[11,"borrow_mut","","",57,[[]]],[11,"try_from","","",57,[[],["result",4]]],[11,"try_into","","",57,[[],["result",4]]],[11,"type_id","","",57,[[],["typeid",3]]],[11,"from","","",58,[[]]],[11,"into","","",58,[[]]],[11,"borrow","","",58,[[]]],[11,"borrow_mut","","",58,[[]]],[11,"try_from","","",58,[[],["result",4]]],[11,"try_into","","",58,[[],["result",4]]],[11,"type_id","","",58,[[],["typeid",3]]],[11,"from","libslide::evaluator_rules::pattern_match","",60,[[]]],[11,"into","","",60,[[]]],[11,"borrow","","",60,[[]]],[11,"borrow_mut","","",60,[[]]],[11,"try_from","","",60,[[],["result",4]]],[11,"try_into","","",60,[[],["result",4]]],[11,"type_id","","",60,[[],["typeid",3]]],[11,"from","libslide::evaluator_rules::registry","",62,[[]]],[11,"into","","",62,[[]]],[11,"borrow","","",62,[[]]],[11,"borrow_mut","","",62,[[]]],[11,"try_from","","",62,[[],["result",4]]],[11,"try_into","","",62,[[],["result",4]]],[11,"type_id","","",62,[[],["typeid",3]]],[11,"from","","",63,[[]]],[11,"into","","",63,[[]]],[11,"to_string","","",63,[[],["string",3]]],[11,"borrow","","",63,[[]]],[11,"borrow_mut","","",63,[[]]],[11,"try_from","","",63,[[],["result",4]]],[11,"try_into","","",63,[[],["result",4]]],[11,"type_id","","",63,[[],["typeid",3]]],[11,"from","","",64,[[]]],[11,"into","","",64,[[]]],[11,"to_owned","","",64,[[]]],[11,"clone_into","","",64,[[]]],[11,"borrow","","",64,[[]]],[11,"borrow_mut","","",64,[[]]],[11,"try_from","","",64,[[],["result",4]]],[11,"try_into","","",64,[[],["result",4]]],[11,"type_id","","",64,[[],["typeid",3]]],[11,"from","libslide::evaluator_rules::rule","",65,[[]]],[11,"into","","",65,[[]]],[11,"to_owned","","",65,[[]]],[11,"clone_into","","",65,[[]]],[11,"to_string","","",65,[[],["string",3]]],[11,"borrow","","",65,[[]]],[11,"borrow_mut","","",65,[[]]],[11,"try_from","","",65,[[],["result",4]]],[11,"try_into","","",65,[[],["result",4]]],[11,"type_id","","",65,[[],["typeid",3]]],[11,"from","","",66,[[]]],[11,"into","","",66,[[]]],[11,"to_string","","",66,[[],["string",3]]],[11,"borrow","","",66,[[]]],[11,"borrow_mut","","",66,[[]]],[11,"try_from","","",66,[[],["result",4]]],[11,"try_into","","",66,[[],["result",4]]],[11,"type_id","","",66,[[],["typeid",3]]],[11,"from","","",67,[[]]],[11,"into","","",67,[[]]],[11,"to_string","","",67,[[],["string",3]]],[11,"borrow","","",67,[[]]],[11,"borrow_mut","","",67,[[]]],[11,"try_from","","",67,[[],["result",4]]],[11,"try_into","","",67,[[],["result",4]]],[11,"type_id","","",67,[[],["typeid",3]]],[11,"from","libslide::evaluator_rules::unbuilt_rule","",68,[[]]],[11,"into","","",68,[[]]],[11,"to_owned","","",68,[[]]],[11,"clone_into","","",68,[[]]],[11,"borrow","","",68,[[]]],[11,"borrow_mut","","",68,[[]]],[11,"try_from","","",68,[[],["result",4]]],[11,"try_into","","",68,[[],["result",4]]],[11,"type_id","","",68,[[],["typeid",3]]],[11,"from","libslide::math::fraction","",69,[[]]],[11,"into","","",69,[[]]],[11,"to_string","","",69,[[],["string",3]]],[11,"borrow","","",69,[[]]],[11,"borrow_mut","","",69,[[]]],[11,"try_from","","",69,[[],["result",4]]],[11,"try_into","","",69,[[],["result",4]]],[11,"type_id","","",69,[[],["typeid",3]]],[11,"from","libslide::utils::grammar","",71,[[]]],[11,"into","","",71,[[]]],[11,"borrow","","",71,[[]]],[11,"borrow_mut","","",71,[[]]],[11,"try_from","","",71,[[],["result",4]]],[11,"try_into","","",71,[[],["result",4]]],[11,"type_id","","",71,[[],["typeid",3]]],[11,"from","libslide::utils::iter","",72,[[]]],[11,"into","","",72,[[]]],[11,"into_iter","","",72,[[]]],[11,"borrow","","",72,[[]]],[11,"borrow_mut","","",72,[[]]],[11,"try_from","","",72,[[],["result",4]]],[11,"try_into","","",72,[[],["result",4]]],[11,"type_id","","",72,[[],["typeid",3]]],[11,"from","","",73,[[]]],[11,"into","","",73,[[]]],[11,"into_iter","","",73,[[]]],[11,"borrow","","",73,[[]]],[11,"borrow_mut","","",73,[[]]],[11,"try_from","","",73,[[],["result",4]]],[11,"try_into","","",73,[[],["result",4]]],[11,"type_id","","",73,[[],["typeid",3]]],[11,"is_const","libslide","",1,[[]]],[11,"is_var","","",1,[[]]],[11,"paren","","",1,[[["span",3],["rcexpr",3]]]],[11,"bracket","","",1,[[["span",3],["rcexpr",3]]]],[11,"binary","","",1,[[["binaryexpr",3],["span",3]]]],[11,"unary","","",1,[[["span",3],["unaryexpr",3]]]],[11,"empty","","",1,[[["span",3]]]],[11,"span","","",1,[[],["span",3]]],[11,"is_const","libslide::grammar::mem","",21,[[]]],[11,"is_var","","",21,[[]]],[11,"paren","","",21,[[["rcexprpat",3],["span",3]]]],[11,"bracket","","",21,[[["rcexprpat",3],["span",3]]]],[11,"binary","","",21,[[["binaryexpr",3],["span",3]]]],[11,"unary","","",21,[[["span",3],["unaryexpr",3]]]],[11,"empty","","",21,[[["span",3]]]],[11,"span","","",21,[[],["span",3]]],[11,"transform","libslide::evaluator_rules::pattern_match","Transforms a pattern expression into an expression by…",60,[[["rcexprpat",3]],["rcexpr",3]]],[11,"transform","","",60,[[["rcexprpat",3]],["rcexprpat",3]]],[11,"transform","libslide::evaluator_rules::rule","Attempts to apply a rule on a target expression by",67,[[["rcexpr",3]],["rcexpr",3]]],[11,"transform","","Bootstraps a rule with another (or possibly the same) rule.",67,[[["rcexprpat",3]],["rcexprpat",3]]],[11,"transform_var","libslide::partial_evaluator::variable_expand","",57,[[["span",3],["internedstr",3]],["rcexpr",3]]],[11,"transform_var","","",58,[[["span",3],["internedstr",3]],["rcexpr",3]]],[11,"visit_var","libslide::grammar::collectors","",23,[[["span",3],["internedstr",3]]]],[11,"visit_asgn","","",24,[[["assignment",3]]]],[11,"visit_asgn_op","libslide::linter::stmt::homogenous_assignment","",46,[[["assignmentop",4]]]],[11,"visit_parend","libslide::linter::stmt::redundant_nesting","",47,[[["span",3],["rcexpr",3]]]],[11,"visit_bracketed","","",47,[[["span",3],["rcexpr",3]]]],[11,"visit_unary","libslide::linter::stmt::unary_series","",48,[[["span",3],["unaryexpr",3]]]],[11,"visit_var_pat","libslide::grammar::collectors","",25,[[["span",3]]]],[11,"visit_const_pat","","",25,[[["span",3]]]],[11,"visit_any_pat","","",25,[[["span",3]]]],[11,"visit_var_pat","libslide::linter::expr_pat::similar_names","",51,[[["span",3]]]],[11,"visit_const_pat","","",51,[[["span",3]]]],[11,"visit_any_pat","","",51,[[["span",3]]]],[11,"codes_with_explanations","libslide::scanner","",75,[[],["vec",3]]],[11,"codes_with_explanations","libslide::parser::errors","",83,[[],["vec",3]]],[11,"codes_with_explanations","libslide::linter","All lint codes and their explanations.",44,[[],["vec",3]]],[11,"codes_with_explanations","libslide::partial_evaluator::errors","",86,[[],["vec",3]]],[11,"input","libslide::parser::expression_pattern_parser","",41,[[],["peekiter",3]]],[11,"push_diag","","",41,[[["diagnostic",3]]]],[11,"parse","","",41,[[],["rcexprpat",3]]],[11,"parse_float","","",41,[[["span",3]]]],[11,"parse_variable","","",41,[[["span",3],["string",3]]]],[11,"parse_var_pattern","","",41,[[["span",3],["string",3]]]],[11,"parse_const_pattern","","",41,[[["span",3],["string",3]]]],[11,"parse_any_pattern","","",41,[[["span",3],["string",3]]]],[11,"has_stmt_break","","",41,[[]]],[11,"input","libslide::parser::statement_parser","",42,[[],["peekiter",3]]],[11,"push_diag","","",42,[[["diagnostic",3]]]],[11,"parse","","",42,[[],["stmtlist",3]]],[11,"parse_float","","",42,[[["span",3]]]],[11,"parse_variable","","",42,[[["span",3],["string",3]]]],[11,"parse_var_pattern","","",42,[[["span",3],["string",3]]]],[11,"parse_const_pattern","","",42,[[["span",3],["string",3]]]],[11,"parse_any_pattern","","",42,[[["span",3],["string",3]]]],[11,"has_stmt_break","","Do we have another statement (on a newline)?",42,[[]]],[11,"lint","libslide::linter::stmt::homogenous_assignment","",46,[[["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[11,"lint","libslide::linter::stmt::redundant_nesting","",47,[[["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[11,"lint","libslide::linter::stmt::unary_series","",48,[[["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[11,"lint","libslide::linter::expr_pat::similar_names","",51,[[["rcexprpat",3]],[["diagnostic",3],["vec",3]]]],[11,"validate","libslide::partial_evaluator::validate::incompatible_definitions","",87,[[["programcontext",3],["stmtlist",3]],[["diagnostic",3],["vec",3]]]],[11,"new","libslide::partial_evaluator::variable_expand","",57,[[["rcexpr",3]]]],[11,"expand","","",57,[[["assignment",3]]]],[11,"finish","","",57,[[],["rcexpr",3]]],[11,"new","","",58,[[["rcexpr",3]]]],[11,"expand","","",58,[[["assignment",3]]]],[11,"finish","","",58,[[],["rcexpr",3]]],[11,"match_rule","libslide::evaluator_rules::pattern_match","",60,[[["rcexprpat",3],["rcexpr",3]],[["patternmatch",3],["option",4]]]],[11,"match_rule","","",60,[[["rcexprpat",3]],[["option",4],["patternmatch",3]]]],[11,"emit_pretty","libslide","",1,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",1,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",1,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","libslide::grammar::mem","",21,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",21,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",21,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","libslide","",3,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",3,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",3,[[["emitconfig",3]],["string",3]]],[11,"emit_wrapped_latex","","",3,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","","",12,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",12,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",12,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","","",2,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",2,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",2,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","libslide::grammar::statement","",27,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",27,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",27,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","libslide","",0,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",0,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",0,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","","",10,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",10,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",10,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","libslide::grammar","",16,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",16,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",16,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","","",14,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",14,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",14,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","","",14,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",14,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",14,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","","",17,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",17,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",17,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","","",15,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",15,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",15,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","","",15,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",15,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",15,[[["emitconfig",3]],["string",3]]],[11,"emit_pretty","libslide","",11,[[["emitconfig",3]],["string",3]]],[11,"emit_s_expression","","",11,[[["emitconfig",3]],["string",3]]],[11,"emit_latex","","",11,[[["emitconfig",3]],["string",3]]],[11,"as_ref","","",1,[[],["expr",4]]],[11,"as_ref","libslide::grammar::mem","",21,[[],["exprpat",4]]],[11,"from","libslide","",12,[[["rcexpr",3]]]],[11,"from","","",12,[[["assignment",3]]]],[11,"from","","",10,[[]]],[11,"from","","",4,[[]]],[11,"from","","",4,[[["range",3]]]],[11,"from","libslide::evaluator_rules::unbuilt_rule","",68,[[]]],[11,"from","libslide","",8,[[["vec",3]],["poly",3]]],[11,"from","","",8,[[["vec",3]],["poly",3]]],[11,"from","","",13,[[["string",3]]]],[11,"from","","",9,[[["vec",3],["string",3]]]],[11,"extend","","",9,[[["intoiterator",8]]]],[11,"into_iter","","",3,[[]]],[11,"next","libslide::grammar::statement","",26,[[],["option",4]]],[11,"next","libslide::utils::iter","",72,[[],["option",4]]],[11,"next","","",73,[[],["option",4]]],[11,"clone","libslide::grammar::mem","",20,[[],["internedstr",3]]],[11,"clone","libslide","",1,[[],["rcexpr",3]]],[11,"clone","libslide::grammar::mem","",21,[[],["rcexprpat",3]]],[11,"clone","libslide","",11,[[],["exprpat",4]]],[11,"clone","","",3,[[],["stmtlist",3]]],[11,"clone","","",12,[[],["stmtkind",4]]],[11,"clone","","",2,[[],["stmt",3]]],[11,"clone","libslide::grammar::statement","",27,[[],["assignmentop",4]]],[11,"clone","libslide","",0,[[],["assignment",3]]],[11,"clone","","",10,[[],["expr",4]]],[11,"clone","libslide::grammar","",16,[[],["binaryoperator",4]]],[11,"clone","","",14,[[],["binaryexpr",3]]],[11,"clone","","",17,[[],["unaryoperator",4]]],[11,"clone","","",15,[[],["unaryexpr",3]]],[11,"clone","libslide","",4,[[],["span",3]]],[11,"clone","libslide::scanner::types","",40,[[],["tokentype",4]]],[11,"clone","","",39,[[],["token",3]]],[11,"clone","libslide::evaluator_rules::registry","",64,[[],["rulename",4]]],[11,"clone","libslide::evaluator_rules::rule","",65,[[],["patternmap",3]]],[11,"clone","libslide::evaluator_rules::unbuilt_rule","",68,[[],["unbuiltrule",4]]],[11,"clone","libslide","",8,[[],["poly",3]]],[11,"clone","","",13,[[],["emitformat",4]]],[11,"clone","","",9,[[],["emitconfig",3]]],[11,"default","libslide::grammar::collectors","",23,[[],["varnamecollector",3]]],[11,"default","","",24,[[],["varasgnscollector",3]]],[11,"default","","",25,[[],["patterncollector",3]]],[11,"default","libslide","",5,[[]]],[11,"default","libslide::linter::expr_pat::similar_names","",50,[[],["namecollection",3]]],[11,"default","","",51,[[],["similarnameslinter",3]]],[11,"default","libslide::linter","",44,[[]]],[11,"default","libslide::evaluator_rules::pattern_match","",60,[[]]],[11,"default","libslide::evaluator_rules::registry","Constructs the default rule set.",62,[[]]],[11,"default","libslide","",8,[[],["poly",3]]],[11,"default","","",9,[[],["emitconfig",3]]],[11,"cmp","","",1,[[],["ordering",4]]],[11,"cmp","libslide::grammar::mem","",21,[[],["ordering",4]]],[11,"cmp","libslide","",11,[[],["ordering",4]]],[11,"cmp","","",10,[[],["ordering",4]]],[11,"cmp","libslide::grammar","",16,[[["binaryoperator",4]],["ordering",4]]],[11,"cmp","","",14,[[],["ordering",4]]],[11,"cmp","","",17,[[["unaryoperator",4]],["ordering",4]]],[11,"cmp","","",15,[[],["ordering",4]]],[11,"cmp","libslide","",4,[[],["ordering",4]]],[11,"cmp","libslide::linter::expr_pat::similar_names","",52,[[["namekind",4]],["ordering",4]]],[11,"cmp","libslide::evaluator_rules::registry","",64,[[],["ordering",4]]],[11,"cmp","libslide","",9,[[["emitconfig",3]],["ordering",4]]],[11,"eq","libslide::grammar::mem","",20,[[["internedstr",3]]]],[11,"ne","","",20,[[["internedstr",3]]]],[11,"eq","libslide","",1,[[]]],[11,"eq","libslide::grammar::mem","",21,[[]]],[11,"eq","libslide","",11,[[["exprpat",4]]]],[11,"eq","","",10,[[["expr",4]]]],[11,"ne","","",10,[[["expr",4]]]],[11,"eq","libslide::grammar","",16,[[["binaryoperator",4]]]],[11,"eq","","",14,[[["binaryexpr",3]]]],[11,"ne","","",14,[[["binaryexpr",3]]]],[11,"eq","","",17,[[["unaryoperator",4]]]],[11,"eq","","",15,[[["unaryexpr",3]]]],[11,"ne","","",15,[[["unaryexpr",3]]]],[11,"eq","libslide","",4,[[["span",3]]]],[11,"ne","","",4,[[["span",3]]]],[11,"eq","libslide::diagnostics","",34,[[["diagnostickind",4]]]],[11,"eq","libslide::scanner::types","",40,[[["tokentype",4]]]],[11,"ne","","",40,[[["tokentype",4]]]],[11,"eq","","",39,[[["token",3]]]],[11,"ne","","",39,[[["token",3]]]],[11,"eq","libslide::linter::expr_pat::similar_names","",52,[[["namekind",4]]]],[11,"eq","libslide::evaluator_rules::registry","",64,[[["rulename",4]]]],[11,"eq","libslide::math::fraction","",69,[[["dec2fracerror",3]]]],[11,"ne","","",69,[[["dec2fracerror",3]]]],[11,"eq","libslide","",8,[[["poly",3]]]],[11,"ne","","",8,[[["poly",3]]]],[11,"eq","","",9,[[["emitconfig",3]]]],[11,"ne","","",9,[[["emitconfig",3]]]],[11,"partial_cmp","","",1,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","libslide::grammar::mem","",21,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","libslide","",11,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","","",10,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","libslide::grammar","",16,[[["binaryoperator",4]],[["option",4],["ordering",4]]]],[11,"partial_cmp","","",14,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","","",17,[[["unaryoperator",4]],[["option",4],["ordering",4]]]],[11,"partial_cmp","","",15,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","libslide","",4,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","libslide::linter::expr_pat::similar_names","",52,[[["namekind",4]],[["option",4],["ordering",4]]]],[11,"partial_cmp","libslide::evaluator_rules::registry","",64,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","libslide","",9,[[["emitconfig",3]],[["option",4],["ordering",4]]]],[11,"lt","","",9,[[["emitconfig",3]]]],[11,"le","","",9,[[["emitconfig",3]]]],[11,"gt","","",9,[[["emitconfig",3]]]],[11,"ge","","",9,[[["emitconfig",3]]]],[11,"deref","libslide::grammar::mem","",18,[[],["rwlock",3]]],[11,"deref","","",19,[[],["internedstr",3]]],[11,"deref","libslide","",1,[[]]],[11,"deref","libslide::grammar::mem","",21,[[]]],[11,"fmt","","",20,[[["formatter",3]],["result",6]]],[11,"fmt","libslide","",1,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar::mem","",21,[[["formatter",3]],["result",6]]],[11,"fmt","libslide","",11,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar::statement","",27,[[["formatter",3]],["result",6]]],[11,"fmt","libslide","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","libslide","",4,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::scanner::types","",40,[[["formatter",3]],["result",6]]],[11,"fmt","","",39,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::linter::expr_pat::similar_names","",52,[[["formatter",3]],["result",6]]],[11,"fmt","","",50,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::evaluator_rules::registry","",64,[[["formatter",3]],["result",6]]],[11,"fmt","","",63,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::evaluator_rules::rule","",65,[[["formatter",3]],["result",6]]],[11,"fmt","","",66,[[["formatter",3]],["result",6]]],[11,"fmt","","",67,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::math::fraction","",69,[[["formatter",3]],["result",6]]],[11,"fmt","libslide","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar::mem","",20,[[["formatter",3]],["result",6]]],[11,"fmt","libslide","",1,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar::mem","",21,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::scanner::types","",40,[[["formatter",3]],["result",6]]],[11,"fmt","","",39,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::linter::expr_pat::similar_names","",52,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::evaluator_rules::registry","",63,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::evaluator_rules::rule","",65,[[["formatter",3]],["result",6]]],[11,"fmt","","",66,[[["formatter",3]],["result",6]]],[11,"fmt","","",67,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::math::fraction","",69,[[["formatter",3]],["result",6]]],[11,"fmt","libslide","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar::statement","",27,[[["formatter",3]],["result",6]]],[11,"fmt","libslide","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","libslide","",11,[[["formatter",3]],["result",6]]],[11,"sub","","Returns the set difference of the two sets of flags.",9,[[["emitconfig",3]],["emitconfig",3]]],[11,"sub_assign","","Disables all flags enabled in the set.",9,[[["emitconfig",3]]]],[11,"not","","Returns the complement of this set of flags.",9,[[],["emitconfig",3]]],[11,"bitand","","Returns the intersection between the two sets of flags.",9,[[["emitconfig",3]],["emitconfig",3]]],[11,"bitor","","Returns the union of the two sets of flags.",9,[[["emitconfig",3]],["emitconfig",3]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",9,[[["emitconfig",3]],["emitconfig",3]]],[11,"bitand_assign","","Disables all flags disabled in the set.",9,[[["emitconfig",3]]]],[11,"bitor_assign","","Adds the set of flags.",9,[[["emitconfig",3]]]],[11,"bitxor_assign","","Toggles the set of flags.",9,[[["emitconfig",3]]]],[11,"hash","libslide::grammar::mem","",20,[[]]],[11,"hash","libslide","",1,[[]]],[11,"hash","libslide::grammar::mem","",21,[[]]],[11,"hash","libslide","",11,[[]]],[11,"hash","","",10,[[]]],[11,"hash","libslide::grammar","",16,[[]]],[11,"hash","","",14,[[]]],[11,"hash","","",17,[[]]],[11,"hash","","",15,[[]]],[11,"hash","libslide","",4,[[]]],[11,"hash","libslide::evaluator_rules::registry","",64,[[]]],[11,"hash","libslide","",9,[[]]],[11,"try_from","libslide::grammar","",16,[[["token",3]],["result",4]]],[11,"try_from","","",17,[[["token",3]],["result",4]]],[11,"from_iter","libslide","",9,[[["intoiterator",8]],["emitconfig",3]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"initialize","libslide::grammar::mem","",18,[[]]],[11,"initialize","","",19,[[]]]],"p":[[3,"Assignment"],[3,"RcExpr"],[3,"Stmt"],[3,"StmtList"],[3,"Span"],[3,"ProgramContext"],[3,"ParseResult"],[3,"EvaluationResult"],[3,"Poly"],[3,"EmitConfig"],[4,"Expr"],[4,"ExprPat"],[4,"StmtKind"],[4,"EmitFormat"],[3,"BinaryExpr"],[3,"UnaryExpr"],[4,"BinaryOperator"],[4,"UnaryOperator"],[3,"INTERNED_STRS"],[3,"EMPTY_STR"],[3,"InternedStr"],[3,"RcExprPat"],[8,"RcExpression"],[3,"VarNameCollector"],[3,"VarAsgnsCollector"],[3,"PatternCollector"],[3,"StmtListIterator"],[4,"AssignmentOp"],[8,"Transformer"],[8,"ExpressionTransformer"],[8,"StmtVisitor"],[8,"ExprPatVisitor"],[3,"AssociatedDiagnostic"],[3,"Diagnostic"],[4,"DiagnosticKind"],[8,"DiagnosticRecord"],[8,"DiagnosticRegistry"],[3,"ScanResult"],[3,"Scanner"],[3,"Token"],[4,"TokenType"],[3,"ExpressionPatternParser"],[3,"ExpressionParser"],[8,"Parser"],[3,"LintConfig"],[4,"StmtLintRule"],[3,"HomogenousAssignmentLinter"],[3,"RedundantNestingLinter"],[3,"UnarySeriesLinter"],[4,"ExprPatLintRule"],[3,"NameCollection"],[3,"SimilarNamesLinter"],[4,"NameKind"],[8,"LintRule"],[4,"EqRelation"],[4,"PEValidator"],[8,"Validator"],[3,"EagerVariableExpander"],[3,"LazyVariableExpander"],[8,"VariableExpander"],[3,"PatternMatch"],[8,"MatchRule"],[3,"RuleSet"],[3,"BuildRuleErrors"],[4,"RuleName"],[3,"PatternMap"],[3,"UnresolvedMapping"],[4,"Rule"],[4,"UnbuiltRule"],[3,"Dec2FracError"],[8,"Emit"],[4,"UnflattenStrategy"],[3,"PeekingTakeWhile"],[3,"PeekIter"],[8,"StringUtils"],[3,"ScanErrors"],[3,"InvalidToken"],[3,"ExtraTokens"],[3,"ExpectedExpr"],[3,"MismatchedClosingDelimiter"],[3,"IllegalPattern"],[3,"IllegalVariable"],[3,"UnmatchedClosingDelimiter"],[3,"ParseErrors"],[3,"IncompatibleDefinitions"],[3,"MaybeIncompatibleDefinitions"],[3,"PartialEvaluatorErrors"],[3,"IncompatibleDefinitionsValidator"]]},\
"slide":{"doc":"The slide app. For an overview of slide\'s design, see…","i":[[3,"Opts","slide","Options to run slide with.",null,null],[12,"program","","Slide program.",0,null],[12,"emit_format","","How the result of slide\'s execution should be emitted.",0,null],[12,"emit_config","","Configuration options for slide emit.",0,null],[12,"lint","","When true, lint warnings for the program will be emitted,…",0,null],[12,"parse_only","","When true, slide will stop after parsing a program.",0,null],[12,"expr_pat","","When true, slide will expect the program to be an…",0,null],[12,"explain_diagnostic","","When is Some diagnostic code, will explain that code.",0,null],[12,"color","","When true, slide emit will be colored.",0,null],[3,"SlideResult","","Output of a slide execution.",null,null],[12,"code","","Exit code",1,null],[12,"stdout","","Emit for stdout",1,null],[12,"stderr","","Emit for stderr",1,null],[12,"page","","Whether the stdout should be emit as paged",1,null],[3,"SlideResultBuilder","","Builds a SlideResult.",null,null],[12,"file","","File the program is defined in. None if the program comes…",2,null],[12,"org_program","","Original slide program source code.",2,null],[12,"sanitized_program","","Program source code sanitized for diagnostic emission.",2,null],[12,"emit_format","","",2,null],[12,"emit_config","","",2,null],[12,"color","","",2,null],[12,"stdout","","",2,null],[12,"stderr","","",2,null],[12,"page","","",2,null],[3,"ProgramEvaluator","","Evaluates a slide program either as a regular program or…",null,null],[12,"result","","",3,null],[12,"tokens","","",3,null],[12,"lint","","",3,null],[12,"parse_only","","",3,null],[5,"get_opts","","Parses Opts from the command line or given a parser that…",null,[[],[["result",4],["opts",3],["error",3]]]],[5,"run_slide","","Runs slide end-to-end.",null,[[["opts",3]],["slideresult",3]]],[0,"diagnostics","","User-facing slide diagnostics.",null,null],[5,"sanitize_source_for_diagnostics","slide::diagnostics","",null,[[],["string",3]]],[5,"emit_slide_diagnostics","","",null,[[["option",4]],["string",3]]],[5,"convert_associated_diagnostic","","Converts a slide AssociatedDiagnostic to a SourceAnnotation.",null,[[["associateddiagnostic",3]],["annotation",3]]],[5,"convert_diagnostic_kind","","Converts a slide DiagnosticKind to an AnnotationType.",null,[[["diagnostickind",4]],["annotationtype",4]]],[11,"new","slide","",2,[[["option",4]]]],[11,"emit","","",2,[[["emit",8]]]],[11,"err","","",2,[[]]],[11,"page","","",2,[[]]],[11,"ok","","",2,[[],["slideresult",3]]],[11,"failed","","",2,[[],["slideresult",3]]],[11,"new","","",3,[[["slideresultbuilder",3],["vec",3],["token",3]]]],[11,"eval_slide_program","","Handles evaluation of a regular slide program (statements,…",3,[[],["slideresult",3]]],[11,"eval_expr_pat","","Handles evaluation of a slide expression pattern.",3,[[],["slideresult",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"default","","",1,[[],["slideresult",3]]]],"p":[[3,"Opts"],[3,"SlideResult"],[3,"SlideResultBuilder"],[3,"ProgramEvaluator"]]},\
"slide_ls":{"doc":"Crate `slide_ls` implements a language server for slide.","i":[[3,"ProgramInfo","slide_ls","",null,null],[12,"source","","",0,null],[12,"original","","",0,null],[12,"simplified","","",0,null],[3,"SlideLS","","A slide language server.",null,null],[12,"client","","",1,null],[12,"document_registry","","",1,null],[12,"context","","",1,null],[5,"main","","",null,[[]]],[0,"services","","Provides langauge services for a slide language server.",null,null],[0,"hover","slide_ls::services","Provides hover services for a slide langauge server. See…",null,null],[3,"ExprFinder","slide_ls::services::hover","",null,null],[12,"tightest","","",2,null],[12,"pos","","",2,null],[5,"get_hover_info","","Returns hover info for an expression.",null,[[["position",3],["programcontext",3]],[["hover",3],["option",4]]]],[5,"fmt_asgn_definitions","","",null,[[],["string",3]]],[5,"fmt_hover_info","","",null,[[["string",3]],["string",3]]],[5,"get_tightest_expr","","",null,[[["stmtlist",3]],[["rcexpr",3],["option",4]]]],[0,"shims","slide_ls","Module `shims` converts between slide and LSP types.",null,null],[5,"convert_diagnostics","slide_ls::shims","",null,[[["url",3]],[["vec",3],["diagnostic",3]]]],[5,"flatten_diagnostic_msg","","",null,[[["diagnostic",3]],["string",3]]],[5,"flatten_related","","",null,[[["diagnostic",3],["url",3]],[["diagnosticrelatedinformation",3],["vec",3]]]],[5,"to_severity","","",null,[[["diagnostickind",4]],["diagnosticseverity",4]]],[5,"to_range","","",null,[[["span",3]],["range",3]]],[5,"to_position","","",null,[[],["position",3]]],[5,"to_offset","","",null,[[["position",3]]]],[6,"DocumentRegistry","slide_ls","",null,null],[11,"new","","Creates a new language server given a server client.",1,[[["client",3]]]],[11,"capabilities","","Returns capabilities of the language server.",1,[[],["servercapabilities",3]]],[11,"change","","",1,[[["option",4],["url",3],["string",3]]]],[11,"close","","",1,[[["url",3]]]],[11,"doc_registry","","",1,[[],[["refcell",3],["mutexguard",6]]]],[11,"get_program_info","","",1,[[["url",3]],[["programinfo",3],["mappedmutexguard",6]]]],[11,"context","","",1,[[],[["mappedmutexguard",6],["programcontext",3]]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","slide_ls::services::hover","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"visit_stmt","","",2,[[["stmt",3]]]],[11,"visit_expr","","",2,[[["rcexpr",3]]]],[11,"initialize","slide_ls","",1,[[["initializeparams",3]],[["pin",3],["box",3]]]],[11,"initialized","","",1,[[["initializedparams",3]],[["box",3],["pin",3]]]],[11,"shutdown","","",1,[[],[["pin",3],["box",3]]]],[11,"did_open","","",1,[[["didopentextdocumentparams",3]],[["box",3],["pin",3]]]],[11,"did_change","","",1,[[["didchangetextdocumentparams",3]],[["box",3],["pin",3]]]],[11,"did_close","","",1,[[["didclosetextdocumentparams",3]],[["box",3],["pin",3]]]],[11,"hover","","",1,[[["hoverparams",3]],[["box",3],["pin",3]]]]],"p":[[3,"ProgramInfo"],[3,"SlideLS"],[3,"ExprFinder"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);